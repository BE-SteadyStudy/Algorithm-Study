## 문제 링크
https://school.programmers.co.kr/learn/courses/30/lessons/1845

## 풀이 방법
첫 번째 시도 (완전 탐색, O(n²))
첫 번째 시도에서는 리스트를 사용하여 중복을 제거하며 숫자를 추가하는 방식을 선택했다. 그러나 리스트의 in 연산은 O(n)의 시간 복잡도를 가지므로 비효율적이었다. 매번 리스트에 새로운 숫자가 존재하는지 확인해야 했기 때문에 전체적으로 O(n²)의 시간 복잡도가 발생했다. 또한, 해시를 활용하지 않았기 때문에 시간 복잡도가 최적화되지 않았다.

두 번째 시도 (해시 활용, O(n))
두 번째 시도에서는 set 자료형을 사용하여 중복을 제거했다. set은 해시 함수를 사용해 충돌을 최소화하며 유일한 인덱스를 보장한다. 이를 통해 중복된 숫자들을 빠르게 제거할 수 있었고, 리스트보다 효율적으로 유일한 값을 관리할 수 있었다. 결과적으로 시간 복잡도를 O(n)으로 줄일 수 있었다.

## 파이썬 코드
````python
def solution(nums):
    # 중복을 제거한 폰켓몬 종류
    set_nums = set(nums)
    # 선택할 수 있는 최대 폰켓몬 수
    return min(len(set_nums), len(nums) // 2)
````